<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!--Description-->
  
  <meta name="description" content="我是一个。。">
  

  <!--Author-->
  
  <meta name="author" content="John Doe">
  

  <!--Open Graph Title-->
  
      <meta property="og:title" content="opp 面向对象编程"/>
  
  <!--Open Graph Description-->
  
      <meta property="og:description" content="我是一个。。" />
  
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="shelly"/>
  <!--Type page-->
  
      <meta property="og:type" content="article" />
  
  <!--Page Cover-->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- 百度统计 -->
    <script>
	var _hmt = _hmt || [];
	(function() {
  	var hm = document.createElement("script");
  	hm.src = "https://hm.baidu.com/hm.js?c0451e16533956173997b85f7a8de666";
  	var s = document.getElementsByTagName("script")[0]; 
  	s.parentNode.insertBefore(hm, s);
	})();
    </script>
  <!-- Title -->
  
  <title>opp 面向对象编程 - shelly</title>


  <link rel="shortcut icon" href="/favicon.ico">
    <!--font-awesome-->
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <!-- Custom CSS/Sass -->
  <link rel="stylesheet" href="/css/style.css">

</head>


<body>

  <!-- Nav -->
  <header class="site-header">
  <div class="header-inside">
    
    <div class="logo">
      <a href="/" rel="home">
        
        <img src="http://oukc6d0xa.bkt.clouddn.com/1_qq_38820348.jpg" alt="shelly" height="60">
        
      </a>
    </div>
    <a class="header-name" href="/">
            <span>shelly</span>
            的部落宅
        </a>
    <!-- navbar -->
    <nav class="navbar">
      <!--  nav links -->
      <div class="collapse">
        <ul class="navbar-nav">
          
          
            <li>
              <a href="/.">
                
                  <i class="fa fa-home "></i>
                
                首页
              </a>
            </li>
          
            <li>
              <a href="/archives">
                
                  <i class="fa fa-archive "></i>
                
                归档
              </a>
            </li>
          
            <li>
              <a href="/about">
                
                  <i class="fa fa-user "></i>
                
                关于
              </a>
            </li>
          
            <li>
              <a href="/project">
                
                  <i class="fa fa-folder-open "></i>
                
                项目
              </a>
            </li>
          
            <li>
              <a href="/photo">
                
                  <i class="fa fa-photo "></i>
                
                相册
              </a>
            </li>
          
            <li>
              <a href="/guestbook">
                
                  <i class="fa fa-edit "></i>
                
                留言
              </a>
            </li>
          
            <li>
              <a href="/atom.xml">
                
                  <i class="fa fa-send "></i>
                
                RSS
              </a>
            </li>
          
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </nav>
    <div class="button-wrap">
      <button class="menu-toggle">Primary Menu</button>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="content-area">
  <div class="post">
    <!-- Post Content -->
    <div class="container">
      <article>
        <!-- Title date & tags -->
        <div class="post-header">
          <h1 class="entry-title">
            opp 面向对象编程
            
          </h1>
         
        </div>
         <p class="a-posted-on">
          2018-11-29
          </p>
        <!-- Post Main Content -->
        <div class="entry-content">
          <a id="more"></a>
<h3 id="opp-（Object-Oriented-Programmin，面向对象的程序设计）。指一种程序设计范型，同时也是一种程序开发的方法论。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。"><a href="#opp-（Object-Oriented-Programmin，面向对象的程序设计）。指一种程序设计范型，同时也是一种程序开发的方法论。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。" class="headerlink" title="opp （Object Oriented Programmin，面向对象的程序设计）。指一种程序设计范型，同时也是一种程序开发的方法论。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。"></a>opp （Object Oriented Programmin，面向对象的程序设计）。指一种程序设计范型，同时也是一种程序开发的方法论。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。</h3><h4 id="下面这张图囊括了面向对象编程的所有内容。"><a href="#下面这张图囊括了面向对象编程的所有内容。" class="headerlink" title="下面这张图囊括了面向对象编程的所有内容。"></a>下面这张图囊括了面向对象编程的所有内容。</h4><p><img src="http://image.winkspace.site/488088-20151224113248624-1189696813.png" alt="avatar"></p>
<h3 id="一、首先我们来看一下面向对象的几大特征"><a href="#一、首先我们来看一下面向对象的几大特征" class="headerlink" title="一、首先我们来看一下面向对象的几大特征"></a>一、首先我们来看一下面向对象的几大特征</h3><p>1、<strong>抽象：</strong> 抽象是将对象的共同特性总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p>2、<strong>继承：</strong> 继承是从已有类得到继承信息创建新类的过程。</p>
<p>3、<strong>封装：</strong> 指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。把敏感的数据封装在类里面，不受外界干扰。只暴露给类外部或者子类必须的属性和操作。</p>
<p>4、<strong>多态：</strong> 多态是在继承的基础上实现的。一般定义为同一个行为作用在不同类的实例上，产生不同的执行结果。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。</p>
<h3 id="二、其次，我们要了解面向对象编程的七大设计原则："><a href="#二、其次，我们要了解面向对象编程的七大设计原则：" class="headerlink" title="二、其次，我们要了解面向对象编程的七大设计原则：**"></a>二、其次，我们要了解面向对象编程的七大设计原则：**</h3><ul>
<li><h4 id="1、开闭原则-Open-Closed-Principle-OCP"><a href="#1、开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="1、开闭原则(Open-Closed Principle, OCP)"></a>1、开闭原则(Open-Closed Principle, OCP)</h4><strong>定 义：</strong> 软件实体应当对拓展开发，对修改关闭，通俗一点说，也就是在软件实体中包括的各种组件、例如模块(models)、类（class）、或者功能（function），在不修改原有代码的基础上，对扩展新的功能，这就是开闭原则中所谓的“开”，那么什么是开闭原则的“闭”，就是说对于代码的修改是封闭的，不允许修改原有的代码。</li>
</ul>
<p><strong>问题由来：</strong> 在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。这就对我们的整个系统的影响特别大，这也充分展现出了系统的耦合性如果太高，会大大的增加后期的扩展，维护。为了解决这个问题，故人们总结出了开闭原则。解决开闭原则的根本其实还是在解耦合。所以，我们面向对象的开发，我们最根本的任务就是解耦合。</p>
<p><strong>小 结：</strong> 开闭原则具有理想主义的色彩，说的很抽象，它是面向对象设计的终极目标。其他几条原则，则可以看做是开闭原则的实现。我们要用抽象构建框架，用实现扩展细节。</p>
<ul>
<li><h3 id="2、单一职责原则（Single-Responsibility-Principle）"><a href="#2、单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="2、单一职责原则（Single Responsibility Principle）"></a>2、单一职责原则（Single Responsibility Principle）</h3><p><strong>定 义：</strong> 一个类只有一个引起变化的原因，即只有一只职责<br> 每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。</p>
<p><strong>问题由来：</strong> 类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
</li>
<li><h3 id="3、里氏替换原则（Liskov-Substitution-Principle）"><a href="#3、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3、里氏替换原则（Liskov Substitution Principle）"></a>3、里氏替换原则（Liskov Substitution Principle）</h3><p><strong>定 义：</strong> 子类型必须能够替换掉它们的父类型。注意这里的能够两字。有人也戏称老鼠的儿子会打洞原则。</p>
</li>
</ul>
<p><strong>问题由来：</strong> 有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p><strong>小 结：</strong> 所有引用父类的地方必须能透明地使用其子类的对象。子类可以扩展父类的功能，但不能改变父类原有的功能，即：子类可以实现父类的抽象方法，子类也中可以增加自己特有的方法，但不能覆盖父类的非抽象方法。当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p>
<ul>
<li><h3 id="4、迪米特法则（Law-Of-Demeter）"><a href="#4、迪米特法则（Law-Of-Demeter）" class="headerlink" title="4、迪米特法则（Law Of Demeter）"></a>4、迪米特法则（Law Of Demeter）</h3><p>又叫最少知识原则，就是说，一个对象应当对其他对象有尽可能少的了解<br>① 在类的划分上，应该创建有弱耦合的类；<br>② 在类的结构设计上，每一个类都应当尽量降低成员的访问权限；<br>③ 在类的设计上，只要有可能，一个类应当设计成不变类；<br>④ 在对其他类的引用上，一个对象对其它对象的引用应当降到最低；<br>⑤ 尽量降低类的访问权限；<br>⑥ 谨慎使用序列化功能；<br>⑦ 不要暴露类成员，而应该提供相应的访问器(属性)。</p>
</li>
<li><h3 id="5、依赖倒置原则（Dependence-Inversion-Principle）"><a href="#5、依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="5、依赖倒置原则（Dependence Inversion Principle）"></a>5、依赖倒置原则（Dependence Inversion Principle）</h3><p><strong>定 义：</strong> 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程。</p>
</li>
</ul>
<p><strong>问题由来：</strong> 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<p><strong>解决方法：</strong> 将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p><strong>小 结：</strong> 依赖倒置原则就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<ul>
<li><h3 id="6、-接口隔离原则（Interface-Segregation-Principle）"><a href="#6、-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="6、 接口隔离原则（Interface Segregation Principle）"></a>6、 接口隔离原则（Interface Segregation Principle）</h3><strong>定 义：</strong> 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
</ul>
<p><strong>问题由来：</strong> 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法</p>
<p><strong>解决方法：</strong> 1、 使用委托分离接口。2、 使用多重继承分离接口。3.将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<ul>
<li><h3 id="7、合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#7、合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="7、合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)"></a>7、合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)</h3>又叫合成复用原则。原则就是在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。<br>就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。这个原则有一个简短的描述：要尽量使用合成、聚合，尽量不要使用继承。</li>
</ul>

        </div>
      </article>
    </div>
    <!-- Pre or Next -->
    
	<div class="container" >
           <ul class="pager">
    	     
      	     <li class="previous">
              <a href="/2018/11/29/opp/" rel="prev">下一篇</a>
             </li>
           
           
              <li class="next">
              <a href="/2018/10/23/test/" rel="prev">上一篇</a>
            </li>
           
          </ul>
       </div>
　　　　<!-- Comments -->
    <div class="container">
      
<section id="comment">
  <!-- <h1 class="title">留言</h1> -->

  
</section>


    </div>
   
　　　　
  </div>
</div>


  <!-- Footer -->
  <!-- Footer -->
<footer class="site-info">
  <p>
    <span>shelly &copy; 2018</span>
    
      <span class="split">|</span>
      <span>shelly的技术小屋</span>
    
  </p>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  本站总访问量<span id="busuanzi_value_site_pv"></span>次
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</footer>


  <!-- After footer scripts -->
  <!-- scripts -->
<script src="/js/app.js"></script>



</body>

</html>
